// 
// gsm4.c
//
// This is an elementary shadowmap example, i.e., depth-map shadows done
// in the shader.
//
// We set up offscreen FBO #1 to hold texture #1 and render to it from 
// the point of view of the light source while storing only depth values.
// We save the transformation used during this render in texture unit 7,
// which is an arbitrarily chosen unit number.  
//
// We then put texture #1 in texture unit 6 (again arbitrary), and 
// render from the intended eye point.  The texture coordinates are
// generated by the vertex shader using the transformation stored
// in texture unit 7.  The fragment shader looks up the stored texture 
// value (saved depth) and compares that with the vertex z under
// the saved transformation.  If these are the same, the vertex was
// lighted.  If the saved depth is smaller, the vertex was shadowed.
//

// gcc gsm4.c -o gsm4 -lX11 -lGL -lGLU -lGLEW -lglut -lm -lXmu -lXi -DGL_GLEXT_PROTOTYPE

#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>
#include <GL/glx.h>
#include <GL/glext.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>

#define NUM_SURFACES 3 
#define XRES 768
#define YRES 768

struct surface {
	char *name;
	/* four corners of this quad */
	float v[4][3];
	float mat_ambient[4];
	float mat_diffuse[4];
	float mat_specular[4];
	float mat_shininess[1];
	};

struct surface surface[NUM_SURFACES] = {
	"floor",
	-1.0, 0.0, -1.0,
	 1.0, 0.0, -1.0,
	 1.0, 0.0,  1.0,
	-1.0, 0.0,  1.0,
         0.0, 0.0, 0.0, 1.0,
         0.8, 0.4, 0.0, 1.0,
         1.0, 1.0, 1.0, 1.0,
         2.0,
	 "table",
         0.0, 0.3, -0.5,
	 0.5, 0.3,  0.0,
	 0.0, 0.3,  0.5,
	-0.5, 0.3,  0.0,
         0.0, 0.0, 0.0, 1.0,
         0.0, 0.4, 0.15,1.0,
         1.0, 1.0, 1.0, 1.0,
         2.0,
	 "other obstacle",
	 -0.25, 0.55, 0.0,
	 -0.25, 0.55, -0.25,
	 0.5, 0.55, -0.25,
	 0.5, 0.55, 0.0,
         0.0, 0.0, 0.0, 1.0,
         0.3, 0.2, 0.65,1.0,
         1.0, 1.0, 1.0, 1.0,
         2.0
	 };

GLfloat light0_position[] = { -0.5, 2.0, -0.5, 1.0 };
GLfloat light0_direction[] = { 0.5, -2.0, 0.5, 1.0};

void lights()
{
glLightfv(GL_LIGHT0,GL_POSITION,light0_position);
}

material(int sindex)
{
glMaterialfv(GL_FRONT,GL_AMBIENT,surface[sindex].mat_ambient);
glMaterialfv(GL_FRONT,GL_DIFFUSE,surface[sindex].mat_diffuse);
glMaterialfv(GL_FRONT,GL_SPECULAR,surface[sindex].mat_specular);
glMaterialfv(GL_FRONT,GL_SHININESS,surface[sindex].mat_shininess);
}


char *read_shader_program(char *filename) 
{
FILE *fp;
char *content = NULL;
int fd, count;
fd = open(filename,O_RDONLY);
count = lseek(fd,0,SEEK_END);
close(fd);
content = (char *)calloc(1,(count+1));
fp = fopen(filename,"r");
count = fread(content,sizeof(char),count,fp);
content[count] = '\0';
fclose(fp);
return content;
}


unsigned int set_shaders()
{
GLint vertCompiled, fragCompiled;
char *vs, *fs;
GLuint v, f, p;

v = glCreateShader(GL_VERTEX_SHADER);
f = glCreateShader(GL_FRAGMENT_SHADER);
vs = read_shader_program("gsm4.vert");
fs = read_shader_program("gsm4_cs.frag");
glShaderSource(v,1,(const char **)&vs,NULL);
glShaderSource(f,1,(const char **)&fs,NULL);
free(vs);
free(fs); 
glCompileShader(v);
glCompileShader(f);
p = glCreateProgram();
glAttachShader(p,f);
glAttachShader(p,v);
glLinkProgram(p);
return(p);
}

void set_uniform(int p)
{
int location;
location = glGetUniformLocation(p,"mytexture");
glUniform1i(location,6);
}

void drawquads()
{
int sindex,k;
glNormal3f(0.0,1.0,0.0);
glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);

for(sindex=0;sindex<NUM_SURFACES;sindex++){
	material(sindex);
	glBegin(GL_QUADS); 
	for(k=0;k<4;k++) glVertex3fv(surface[sindex].v[k]);
	glEnd();
	}
glFlush();
}

void build_shadowmap()
{
// Set properties of texture id #1.
glBindTexture(GL_TEXTURE_2D,1);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP );
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP );
// Declare size and type of texture; it has no data initially (last arg 0).
glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, XRES, YRES, 0, 
	GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, 0);
// Back to default.
glBindTexture(GL_TEXTURE_2D, 0);

glBindFramebufferEXT(GL_FRAMEBUFFER,1);
glDrawBuffer(GL_NONE); // No color buffers will be written.
// Attach this framebuffer (id #1 above) to texture (id #1 is penultimate arg),
// so that we can perform an offscreen render-to-texture.
glFramebufferTexture2D(GL_FRAMEBUFFER,GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D,1,0);
// Back to default.
glBindFramebufferEXT(GL_FRAMEBUFFER,0);
}

void save_matrix(float *ep, float *vp)
{
glMatrixMode(GL_TEXTURE); 
// This must match the unit used in the vertex shader.
glActiveTexture(GL_TEXTURE7);
glLoadIdentity();
glTranslatef(0.0,0.0,-0.005);
// glTranslatef(0.0,0.0,0.005);
glScalef(0.5,0.5,0.5);
glTranslatef(1.0,1.0,1.0);
gluPerspective(45.0,(float)(XRES)/(float)(YRES),0.1,20.0);
gluLookAt(ep[0],ep[1],ep[2],vp[0],vp[1],vp[2],0.0,1.0,0.0);
}

void view_volume(float *ep, float *vp)
{
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
gluPerspective(45.0,(float)(XRES)/(float)(YRES),0.1,20.0);
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
gluLookAt(ep[0],ep[1],ep[2],vp[0],vp[1],vp[2],0.0,1.0,0.0);
}

GLuint sprogram;

void do_stuff()
{
float eyepoint[3], viewpoint[3];
int k;

glEnable(GL_MULTISAMPLE_ARB);
glEnable(GL_DEPTH_TEST);

glClearColor(0.8,0.6,0.62,1.0);

// Render first from the point of view of the light source.  This render will 
// go to texture (#1) in offscreen FBO, and it will not use shaders.
glBindFramebufferEXT(GL_FRAMEBUFFER,1); 
glUseProgram(0);
for(k=0;k<3;k++){ 
	eyepoint[k] = light0_position[k]; 
	viewpoint[k] = light0_direction[k]+light0_position[k];
	}
view_volume(eyepoint,viewpoint);
// Set lights after vv so that shader can assume eye coordinates.
lights(); 
drawquads();
glBindFramebufferEXT(GL_FRAMEBUFFER,0); 

// Save the "view from eyepoint" transformation.
save_matrix(eyepoint,viewpoint);

// Switch to the shader and use texture #1.
glUseProgram(sprogram);
set_uniform(sprogram);
// This unit number must match that set as a uniform value for the
// fragment shader.
glActiveTexture(GL_TEXTURE6);
glBindTexture(GL_TEXTURE_2D,1);

// Draw scene from the intended eye point, complete with shadows. 
eyepoint[0] = 1.0; eyepoint[1] = 2.0; eyepoint[2] = 2.0;
viewpoint[0] = 0.0; viewpoint[1] = 0.0; viewpoint[1] = 0.0;
view_volume(eyepoint,viewpoint);
lights(); 
drawquads();
glutSwapBuffers();
}

void getout(unsigned char key, int x, int y)
{
switch(key) {
        case 'q':
                exit(1);
        default:
                break;
    }
}

int main(int argc, char **argv)
{
glutInit(&argc,argv);
glutInitDisplayMode(GLUT_RGBA|GLUT_DEPTH|GLUT_DOUBLE|GLUT_MULTISAMPLE);
glutInitWindowSize(XRES,YRES);
glutInitWindowPosition(300,50);
glutCreateWindow("view from light source, then from eye");
build_shadowmap();
sprogram=set_shaders();
glutDisplayFunc(do_stuff);
glutKeyboardFunc(getout);
glutMainLoop();
return 0;
}

